// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.2.4 (swiftlang-1103.0.32.9 clang-1103.0.32.53)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Beacon
@_exported import Beacon
import CommonCrypto
import CoreData
import CoreFoundation
import Foundation
import MobileCoreServices
import Beacon.Private
import QuickLook
import Security
import Swift
import SystemConfiguration
import UIKit
import zlib
@objc public protocol AuthRequestBuilderProtocol {
  @objc optional func requestFor(socketID: Swift.String, channelName: Swift.String) -> Foundation.URLRequest?
}
@objc public protocol Authorizer {
  @objc func fetchAuthValue(socketID: Swift.String, channelName: Swift.String, completionHandler: @escaping (Beacon.PusherAuth?) -> ())
}
public protocol CancelableOperation {
  func cancel()
}
extension URLSessionDataTask : Beacon.CancelableOperation {
}
public typealias Reducer<Value, Action> = (inout Value, Action) -> [Beacon.Effect<Action>]
public func logging<Value, Action>(_ reducer: @escaping Beacon.Reducer<Value, Action>) -> Beacon.Reducer<Value, Action>
public func combine<State, Action>(_ reducers: Beacon.Reducer<State, Action>...) -> Beacon.Reducer<State, Action>
public struct Tagged<Tag, RawValue> {
  public var rawValue: RawValue
  public init(rawValue: RawValue)
  public func map<B>(_ f: (RawValue) -> B) -> Beacon.Tagged<Tag, B>
}
extension Tagged : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Tagged : Swift.RawRepresentable {
}
extension Tagged : Swift.Equatable where RawValue : Swift.Equatable {
}
extension Tagged : Swift.ExpressibleByExtendedGraphemeClusterLiteral where RawValue : Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = RawValue.ExtendedGraphemeClusterLiteralType
  public init(extendedGraphemeClusterLiteral: Beacon.Tagged<Tag, RawValue>.ExtendedGraphemeClusterLiteralType)
}
extension Tagged : Swift.ExpressibleByStringLiteral where RawValue : Swift.ExpressibleByStringLiteral {
  public typealias StringLiteralType = RawValue.StringLiteralType
  public init(stringLiteral: Beacon.Tagged<Tag, RawValue>.StringLiteralType)
}
extension Tagged : Swift.ExpressibleByUnicodeScalarLiteral where RawValue : Swift.ExpressibleByUnicodeScalarLiteral {
  public typealias UnicodeScalarLiteralType = RawValue.UnicodeScalarLiteralType
  public init(unicodeScalarLiteral: Beacon.Tagged<Tag, RawValue>.UnicodeScalarLiteralType)
}
extension Tagged : Swift.Decodable where RawValue : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension Tagged : Swift.Encodable where RawValue : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@objc @_inheritsConvenienceInitializers public class ChatDependencies : ObjectiveC.NSObject {
  @objc public class func setTintColorSettings(_ tintColor: Beacon.HSBeaconTintColor)
  @objc public class func setStringLocalizer(_ stringLocalizer: Beacon.HSBeaconStringLocalizer)
  @objc public class func setBeaconConfig(_ config: Beacon.HSBeaconConfig)
  @objc public class func setBeaconID(_ beaconID: Swift.String)
  @objc public class func setDeviceID(_ deviceID: Swift.String)
  @objc public class func setChatEndedDelegate(_ delegate: Beacon.HSBeaconChatEndedDelegate?)
  @objc public class func setBeaconAgents(_ agents: [Beacon.HSBeaconAgent])
  @objc public class func setEnablePreviousMessages(_ enabled: Swift.Bool)
  @objc public class func setAttachmentsEnabled(_ enabled: Swift.Bool)
  @objc public class func setPushNotficationSupport(_ support: Beacon.HSBeaconPushNotificationSupport)
  @objc public class func hasPausedChat() -> Swift.Bool
  @objc public class func chatViewControllerClass() -> Swift.AnyClass
  @objc public class func endChat()
  @objc public class func didChatGenerateConversationWithId(_ id: Swift.String) -> Swift.Bool
  @objc deinit
  @objc override dynamic public init()
}
public func decode<A>(_ data: Foundation.Data) -> Swift.Result<A, Swift.DecodingError> where A : Swift.Decodable
public func decode<A>(_ data: Foundation.Data, with decoder: Foundation.JSONDecoder) -> Swift.Result<A, Swift.DecodingError> where A : Swift.Decodable
public struct Effect<A> {
  public let run: (@escaping (A) -> Swift.Void) -> Swift.Void
  public init(run: @escaping (@escaping (A) -> Swift.Void) -> Swift.Void)
  public func map<B>(_ f: @escaping (A) -> B) -> Beacon.Effect<B>
}
@objc public protocol HSEnterEmailViewControllerDelegate {
  @objc func enterEmailController(_ controller: Beacon.HSEnterEmailViewController, didEnter email: Swift.String)
}
@_inheritsConvenienceInitializers @objc public class HSEnterEmailViewController : UIKit.UIViewController {
  @objc weak public var delegate: Beacon.HSEnterEmailViewControllerDelegate?
  @objc public static func instantiateViewController() -> Beacon.HSEnterEmailViewController
  @objc override dynamic public func viewDidLoad()
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public enum HTTPMethod : Swift.Equatable {
  case options
  case get
  case head
  case post(Foundation.Data?)
  case put(Foundation.Data?)
  case patch(Foundation.Data?)
  case delete
  case trace
  case connect
  public var body: Foundation.Data? {
    get
  }
  public var rawValue: Swift.String {
    get
  }
  public static func == (a: Beacon.HTTPMethod, b: Beacon.HTTPMethod) -> Swift.Bool
}
@objc extension Pusher {
  @objc dynamic public func subscribe(channelName: Swift.String) -> Beacon.PusherChannel
  @objc dynamic public func subscribe(channelName: Swift.String, onMemberAdded: ((Beacon.PusherPresenceChannelMember) -> ())? = nil, onMemberRemoved: ((Beacon.PusherPresenceChannelMember) -> ())? = nil) -> Beacon.PusherChannel
  @objc dynamic public func subscribeToPresenceChannel(channelName: Swift.String) -> Beacon.PusherPresenceChannel
  @objc dynamic public func subscribeToPresenceChannel(channelName: Swift.String, onMemberAdded: ((Beacon.PusherPresenceChannelMember) -> ())? = nil, onMemberRemoved: ((Beacon.PusherPresenceChannelMember) -> ())? = nil) -> Beacon.PusherPresenceChannel
  @objc convenience dynamic public init(withAppKey key: Swift.String, options: Beacon.PusherClientOptions)
  @objc convenience dynamic public init(withKey key: Swift.String)
}
@objc extension PusherConnection {
  @objc dynamic public var OCReconnectAttemptsMax: Foundation.NSNumber? {
    @objc get
    @objc set(newValue)
  }
  @objc dynamic public var OCMaxReconnectGapInSeconds: Foundation.NSNumber? {
    @objc get
    @objc set(newValue)
  }
}
@objc extension PusherClientOptions {
  @objc convenience dynamic public init(ocAuthMethod authMethod: Beacon.OCAuthMethod, autoReconnect: Swift.Bool = true, ocHost host: Beacon.OCPusherHost = PusherHost.host("ws.pusherapp.com").toObjc(), port: Foundation.NSNumber? = nil, useTLS: Swift.Bool = true, activityTimeout: Foundation.NSNumber? = nil)
  @objc convenience dynamic public init(ocAuthMethod authMethod: Beacon.OCAuthMethod, attemptToReturnJSONObject: Swift.Bool = true, autoReconnect: Swift.Bool = true, ocHost host: Beacon.OCPusherHost = PusherHost.host("ws.pusherapp.com").toObjc(), port: Foundation.NSNumber? = nil, useTLS: Swift.Bool = true, activityTimeout: Foundation.NSNumber? = nil)
  @objc convenience dynamic public init(authMethod: Beacon.OCAuthMethod)
  @objc dynamic public func setAuthMethod(authMethod: Beacon.OCAuthMethod)
}
extension PusherHost {
  public func toObjc() -> Beacon.OCPusherHost
  public static func fromObjc(source: Beacon.OCPusherHost) -> Beacon.PusherHost
}
@_inheritsConvenienceInitializers @objcMembers @objc public class OCPusherHost : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public init(host: Swift.String)
  @objc public init(cluster: Swift.String)
  @objc deinit
}
extension AuthMethod {
  public func toObjc() -> Beacon.OCAuthMethod
  public static func fromObjc(source: Beacon.OCAuthMethod) -> Beacon.AuthMethod
}
@objcMembers @objc public class OCAuthMethod : ObjectiveC.NSObject {
  @objc public init(type: Swift.Int)
  @objc public init(authEndpoint: Swift.String)
  @objc public init(authRequestBuilder: Beacon.AuthRequestBuilderProtocol)
  @objc public init(secret: Swift.String)
  @objc public init(authorizer: Beacon.Authorizer)
  @objc deinit
  @objc override dynamic public init()
}
extension PusherError {
  @objc dynamic public var codeOC: Foundation.NSNumber? {
    @objc get
  }
}
public enum PusherChannelType {
  case `private`
  case presence
  case normal
  public init(name: Swift.String)
  public static func type(forName name: Swift.String) -> Beacon.PusherChannelType
  public static func isPresenceChannel(name: Swift.String) -> Swift.Bool
  public static func == (a: Beacon.PusherChannelType, b: Beacon.PusherChannelType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc @objcMembers open class PusherChannel : ObjectiveC.NSObject {
  open var eventHandlers: [Swift.String : [Beacon.EventHandler]]
  @objc open var subscribed: Swift.Bool
  @objc final public let name: Swift.String
  @objc weak open var connection: Beacon.PusherConnection?
  open var unsentEvents: [Beacon.QueuedClientEvent]
  final public let type: Beacon.PusherChannelType
  @objc public var auth: Beacon.PusherAuth?
  @objc public init(name: Swift.String, connection: Beacon.PusherConnection, auth: Beacon.PusherAuth? = nil)
  @objc @discardableResult
  open func bind(eventName: Swift.String, callback: @escaping (Any?) -> Swift.Void) -> Swift.String
  @objc @discardableResult
  open func bind(eventName: Swift.String, eventCallback: @escaping (Beacon.PusherEvent) -> Swift.Void) -> Swift.String
  @objc open func unbind(eventName: Swift.String, callbackId: Swift.String)
  @objc open func unbindAll()
  @objc open func unbindAll(forEventName eventName: Swift.String)
  @objc open func handleEvent(event: Beacon.PusherEvent)
  @objc open func trigger(eventName: Swift.String, data: Any)
  @objc deinit
  @objc override dynamic public init()
}
public struct EventHandler {
}
public struct QueuedClientEvent {
  public let name: Swift.String
  public let data: Any
}
@_inheritsConvenienceInitializers @objcMembers @objc open class PusherChannels : ObjectiveC.NSObject {
  @objc open var channels: [Swift.String : Beacon.PusherChannel]
  @objc public func find(name: Swift.String) -> Beacon.PusherChannel?
  @objc public func findPresence(name: Swift.String) -> Beacon.PusherPresenceChannel?
  @objc deinit
  @objc override dynamic public init()
}
public enum PusherHost {
  case host(Swift.String)
  case cluster(Swift.String)
  public var stringValue: Swift.String {
    get
  }
}
public enum AuthMethod {
  case endpoint(authEndpoint: Swift.String)
  case authRequestBuilder(authRequestBuilder: Beacon.AuthRequestBuilderProtocol)
  case authorizer(authorizer: Beacon.Authorizer)
  case inline(secret: Swift.String)
  case noMethod
}
@objcMembers @objc public class PusherClientOptions : ObjectiveC.NSObject {
  public var authMethod: Beacon.AuthMethod
  @objc final public let attemptToReturnJSONObject: Swift.Bool
  @objc final public let autoReconnect: Swift.Bool
  @objc final public let host: Swift.String
  @objc final public let port: Swift.Int
  @objc final public let useTLS: Swift.Bool
  final public let activityTimeout: Foundation.TimeInterval?
  @nonobjc public init(authMethod: Beacon.AuthMethod = .noMethod, attemptToReturnJSONObject: Swift.Bool = true, autoReconnect: Swift.Bool = true, host: Beacon.PusherHost = .host("ws.pusherapp.com"), port: Swift.Int? = nil, useTLS: Swift.Bool = true, activityTimeout: Foundation.TimeInterval? = nil)
  @objc override dynamic public init()
  @objc deinit
}
@objcMembers @objc open class PusherConnection : ObjectiveC.NSObject {
  @objc final public let url: Swift.String
  @objc final public let key: Swift.String
  @objc open var options: Beacon.PusherClientOptions
  @objc open var globalChannel: Beacon.GlobalChannel!
  @objc open var socketId: Swift.String?
  @objc open var connectionState: Beacon.ConnectionState
  @objc open var channels: Beacon.PusherChannels
  @objc open var socket: Beacon.WebSocket!
  @objc open var URLSession: Foundation.URLSession
  @objc open var userDataFetcher: (() -> Beacon.PusherPresenceChannelMember)?
  open var reconnectAttemptsMax: Swift.Int?
  @objc open var reconnectAttempts: Swift.Int
  open var maxReconnectGapInSeconds: Swift.Double?
  @objc weak open var delegate: Beacon.PusherDelegate?
  @objc open var pongResponseTimeoutInterval: Foundation.TimeInterval
  @objc open var activityTimeoutInterval: Foundation.TimeInterval
  open var reachability: Beacon.Reachability? {
    get
    set
  }
  @objc public init(key: Swift.String, socket: Beacon.WebSocket, url: Swift.String, options: Beacon.PusherClientOptions, URLSession: Foundation.URLSession = Foundation.URLSession.shared)
  @objc deinit
  @objc open func sendEvent(event: Swift.String, data: Any, channel: Beacon.PusherChannel? = nil)
  @objc open func disconnect()
  @objc open func connect()
  @objc open func handleError(error: Beacon.PusherError)
  @objc open func handleEvent(event: Beacon.PusherEvent)
  @objc override dynamic public init()
}
@objc public class PusherAuth : ObjectiveC.NSObject {
  final public let auth: Swift.String
  final public let channelData: Swift.String?
  final public let sharedSecret: Swift.String?
  public init(auth: Swift.String, channelData: Swift.String? = nil, sharedSecret: Swift.String? = nil)
  @objc deinit
  @objc override dynamic public init()
}
@objc public enum ConnectionState : Swift.Int {
  case connecting
  case connected
  case disconnecting
  case disconnected
  case reconnecting
  public func stringValue() -> Swift.String
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol PusherDelegate : AnyObject {
  @objc optional func debugLog(message: Swift.String)
  @objc optional func changedConnectionState(from old: Beacon.ConnectionState, to new: Beacon.ConnectionState)
  @objc optional func subscribedToChannel(name: Swift.String)
  @objc optional func failedToSubscribeToChannel(name: Swift.String, response: Foundation.URLResponse?, data: Swift.String?, error: Foundation.NSError?)
  @objc optional func failedToDecryptEvent(eventName: Swift.String, channelName: Swift.String, data: Swift.String?)
  @objc(receivedError:) optional func receivedError(error: Beacon.PusherError)
}
@objc @_hasMissingDesignatedInitializers @objcMembers open class PusherError : ObjectiveC.NSObject {
  final public let code: Swift.Int?
  @objc final public let message: Swift.String
  @objc deinit
  @objc override dynamic public init()
}
@objc @_hasMissingDesignatedInitializers @objcMembers open class PusherEvent : ObjectiveC.NSObject, Foundation.NSCopying {
  @objc final public let eventName: Swift.String
  @objc final public let channelName: Swift.String?
  @objc final public let data: Swift.String?
  @objc final public let userId: Swift.String?
  @objc public func property(withKey key: Swift.String) -> Any?
  @objc public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @objc deinit
  @objc override dynamic public init()
}
@_hasMissingDesignatedInitializers @objcMembers @objc open class GlobalChannel : Beacon.PusherChannel {
  open var globalCallbacks: [Swift.String : (Beacon.PusherEvent) -> Swift.Void]
  open var globalLegacyCallbacks: [Swift.String : (Any?) -> Swift.Void]
  @objc override open func unbindAll()
  @objc override public init(name: Swift.String, connection: Beacon.PusherConnection, auth: Beacon.PusherAuth? = super)
  @objc deinit
}
public typealias PusherUserInfoObject = [Swift.String : Swift.AnyObject]
@_hasMissingDesignatedInitializers @objcMembers @objc open class PusherPresenceChannel : Beacon.PusherChannel {
  @objc open var members: [Beacon.PusherPresenceChannelMember]
  @objc open var onMemberAdded: ((Beacon.PusherPresenceChannelMember) -> ())?
  @objc open var onMemberRemoved: ((Beacon.PusherPresenceChannelMember) -> ())?
  @objc open var myId: Swift.String?
  @objc open func findMember(userId: Swift.String) -> Beacon.PusherPresenceChannelMember?
  @objc open func me() -> Beacon.PusherPresenceChannelMember?
  @objc override public init(name: Swift.String, connection: Beacon.PusherConnection, auth: Beacon.PusherAuth? = super)
  @objc deinit
}
@objcMembers @objc public class PusherPresenceChannelMember : ObjectiveC.NSObject {
  @objc final public let userId: Swift.String
  @objc final public let userInfo: Any?
  @objc public init(userId: Swift.String, userInfo: Any? = nil)
  @objc deinit
  @objc override dynamic public init()
}
@objcMembers @objc open class Pusher : ObjectiveC.NSObject {
  @objc final public let connection: Beacon.PusherConnection
  @objc weak open var delegate: Beacon.PusherDelegate? {
    @objc get
    @objc set
  }
  @objc public init(key: Swift.String, options: Beacon.PusherClientOptions = PusherClientOptions())
  @objc open func subscribe(_ channelName: Swift.String, auth: Beacon.PusherAuth? = nil, onMemberAdded: ((Beacon.PusherPresenceChannelMember) -> ())? = nil, onMemberRemoved: ((Beacon.PusherPresenceChannelMember) -> ())? = nil) -> Beacon.PusherChannel
  @objc open func subscribeToPresenceChannel(channelName: Swift.String, auth: Beacon.PusherAuth? = nil, onMemberAdded: ((Beacon.PusherPresenceChannelMember) -> ())? = nil, onMemberRemoved: ((Beacon.PusherPresenceChannelMember) -> ())? = nil) -> Beacon.PusherPresenceChannel
  @objc open func unsubscribe(_ channelName: Swift.String)
  @objc open func unsubscribeAll()
  @objc @discardableResult
  open func bind(_ callback: @escaping (Any?) -> Swift.Void) -> Swift.String
  @objc @discardableResult
  open func bind(eventCallback: @escaping (Beacon.PusherEvent) -> Swift.Void) -> Swift.String
  @objc open func unbind(callbackId: Swift.String)
  @objc open func unbindAll()
  @objc open func disconnect()
  @objc open func connect()
  @objc override dynamic public init()
  @objc deinit
}
extension PusherConnection : Beacon.WebSocketDelegate {
  public func websocketDidReceiveMessage(socket ws: Beacon.WebSocketClient, text: Swift.String)
  public func websocketDidDisconnect(socket ws: Beacon.WebSocketClient, error: Swift.Error?)
  public func websocketDidConnect(socket ws: Beacon.WebSocketClient)
  public func websocketDidReceiveData(socket ws: Beacon.WebSocketClient, data: Foundation.Data)
}
extension PusherConnection : Beacon.WebSocketPongDelegate {
  public func websocketDidReceivePong(socket: Beacon.WebSocketClient, data: Foundation.Data?)
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (Beacon.Reachability) -> ()
  public typealias NetworkUnreachable = (Beacon.Reachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: Beacon.Reachability.NetworkStatus, b: Beacon.Reachability.NetworkStatus) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Connection : Swift.CustomStringConvertible {
    @available(*, deprecated, renamed: "unavailable")
    case none
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: Beacon.Reachability.Connection, b: Beacon.Reachability.Connection) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var whenReachable: Beacon.Reachability.NetworkReachable?
  public var whenUnreachable: Beacon.Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: Beacon.Reachability.Connection {
    get
  }
  public var connection: Beacon.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public struct SSLClientCertificateError : Foundation.LocalizedError {
  public var errorDescription: Swift.String?
}
public class SSLClientCertificate {
  convenience public init(pkcs12Path: Swift.String, password: Swift.String) throws
  public init(identity: Security.SecIdentity, identityCertificate: Security.SecCertificate)
  convenience public init(pkcs12Url: Foundation.URL, password: Swift.String) throws
  public init(pkcs12Url: Foundation.URL, importOptions: CoreFoundation.CFDictionary) throws
  @objc deinit
}
public protocol SSLTrustValidator {
  func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
}
open class SSLCert {
  public init(data: Foundation.Data)
  public init(key: Security.SecKey)
  @objc deinit
}
open class SSLSecurity : Beacon.SSLTrustValidator {
  public var validatedDN: Swift.Bool
  public var validateEntireChain: Swift.Bool
  convenience public init(usePublicKeys: Swift.Bool = false)
  public init(certs: [Beacon.SSLCert], usePublicKeys: Swift.Bool)
  open func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
  public func extractPublicKey(_ data: Foundation.Data) -> Security.SecKey?
  public func extractPublicKey(_ cert: Security.SecCertificate, policy: Security.SecPolicy) -> Security.SecKey?
  public func certificateChain(_ trust: Security.SecTrust) -> [Foundation.Data]
  public func publicKeyChain(_ trust: Security.SecTrust) -> [Security.SecKey]
  @objc deinit
}
public let WebsocketDidConnectNotification: Swift.String
public let WebsocketDidDisconnectNotification: Swift.String
public let WebsocketDisconnectionErrorKeyName: Swift.String
public enum CloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public typealias RawValue = Swift.UInt16
  public init?(rawValue: Swift.UInt16)
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum ErrorType : Swift.Error {
  case outputStreamWriteError
  case compressionError
  case invalidSSLError
  case writeTimeoutError
  case protocolError
  case upgradeError
  case closeError
  public static func == (a: Beacon.ErrorType, b: Beacon.ErrorType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct WSError : Swift.Error {
  public let type: Beacon.ErrorType
  public let message: Swift.String
  public let code: Swift.Int
}
public protocol WebSocketClient : AnyObject {
  var delegate: Beacon.WebSocketDelegate? { get set }
  var pongDelegate: Beacon.WebSocketPongDelegate? { get set }
  var disableSSLCertValidation: Swift.Bool { get set }
  var overrideTrustHostname: Swift.Bool { get set }
  var desiredTrustHostname: Swift.String? { get set }
  var sslClientCertificate: Beacon.SSLClientCertificate? { get set }
  var security: Beacon.SSLTrustValidator? { get set }
  var enabledSSLCipherSuites: [Security.SSLCipherSuite]? { get set }
  var isConnected: Swift.Bool { get }
  func connect()
  func disconnect(forceTimeout: Foundation.TimeInterval?, closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: (() -> ())?)
  func write(data: Foundation.Data, completion: (() -> ())?)
  func write(ping: Foundation.Data, completion: (() -> ())?)
  func write(pong: Foundation.Data, completion: (() -> ())?)
}
extension WebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public struct SSLSettings {
  public let useSSL: Swift.Bool
  public let disableCertValidation: Swift.Bool
  public var overrideTrustHostname: Swift.Bool
  public var desiredTrustHostname: Swift.String?
  public let sslClientCertificate: Beacon.SSLClientCertificate?
  public let cipherSuites: [Security.SSLCipherSuite]?
}
public protocol WSStreamDelegate : AnyObject {
  func newBytesInStream()
  func streamDidError(error: Swift.Error?)
}
public protocol WSStream {
  var delegate: Beacon.WSStreamDelegate? { get set }
  func connect(url: Foundation.URL, port: Swift.Int, timeout: Foundation.TimeInterval, ssl: Beacon.SSLSettings, completion: @escaping ((Swift.Error?) -> Swift.Void))
  func write(data: Foundation.Data) -> Swift.Int
  func read() -> Foundation.Data?
  func cleanup()
  func sslTrust() -> (trust: Security.SecTrust?, domain: Swift.String?)
}
@objc @_inheritsConvenienceInitializers open class FoundationStream : ObjectiveC.NSObject, Beacon.WSStream, Foundation.StreamDelegate {
  weak public var delegate: Beacon.WSStreamDelegate?
  public var enableSOCKSProxy: Swift.Bool
  public func connect(url: Foundation.URL, port: Swift.Int, timeout: Foundation.TimeInterval, ssl: Beacon.SSLSettings, completion: @escaping ((Swift.Error?) -> Swift.Void))
  public func write(data: Foundation.Data) -> Swift.Int
  public func read() -> Foundation.Data?
  public func cleanup()
  public func sslTrust() -> (trust: Security.SecTrust?, domain: Swift.String?)
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
  @objc deinit
  @objc override dynamic public init()
}
public protocol WebSocketDelegate : AnyObject {
  func websocketDidConnect(socket: Beacon.WebSocketClient)
  func websocketDidDisconnect(socket: Beacon.WebSocketClient, error: Swift.Error?)
  func websocketDidReceiveMessage(socket: Beacon.WebSocketClient, text: Swift.String)
  func websocketDidReceiveData(socket: Beacon.WebSocketClient, data: Foundation.Data)
}
public protocol WebSocketPongDelegate : AnyObject {
  func websocketDidReceivePong(socket: Beacon.WebSocketClient, data: Foundation.Data?)
}
public protocol WebSocketAdvancedDelegate : AnyObject {
  func websocketDidConnect(socket: Beacon.WebSocket)
  func websocketDidDisconnect(socket: Beacon.WebSocket, error: Swift.Error?)
  func websocketDidReceiveMessage(socket: Beacon.WebSocket, text: Swift.String, response: Beacon.WebSocket.WSResponse)
  func websocketDidReceiveData(socket: Beacon.WebSocket, data: Foundation.Data, response: Beacon.WebSocket.WSResponse)
  func websocketHttpUpgrade(socket: Beacon.WebSocket, request: Swift.String)
  func websocketHttpUpgrade(socket: Beacon.WebSocket, response: Swift.String)
}
@objc open class WebSocket : ObjectiveC.NSObject, Foundation.StreamDelegate, Beacon.WebSocketClient, Beacon.WSStreamDelegate {
  public enum OpCode : Swift.UInt8 {
    case continueFrame
    case textFrame
    case binaryFrame
    case connectionClose
    case ping
    case pong
    public typealias RawValue = Swift.UInt8
    public init?(rawValue: Swift.UInt8)
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public static let ErrorDomain: Swift.String
  public var callbackQueue: Dispatch.DispatchQueue
  @_hasMissingDesignatedInitializers public class WSResponse {
    public var code: Beacon.WebSocket.OpCode
    public var frameCount: Swift.Int
    public var buffer: Foundation.NSMutableData?
    final public let firstFrame: Foundation.Date
    @objc deinit
  }
  weak public var delegate: Beacon.WebSocketDelegate?
  weak public var advancedDelegate: Beacon.WebSocketAdvancedDelegate?
  weak public var pongDelegate: Beacon.WebSocketPongDelegate?
  public var onConnect: (() -> Swift.Void)?
  public var onDisconnect: ((Swift.Error?) -> Swift.Void)?
  public var onText: ((Swift.String) -> Swift.Void)?
  public var onData: ((Foundation.Data) -> Swift.Void)?
  public var onPong: ((Foundation.Data?) -> Swift.Void)?
  public var onHttpResponseHeaders: (([Swift.String : Swift.String]) -> Swift.Void)?
  public var disableSSLCertValidation: Swift.Bool
  public var overrideTrustHostname: Swift.Bool
  public var desiredTrustHostname: Swift.String?
  public var sslClientCertificate: Beacon.SSLClientCertificate?
  public var enableCompression: Swift.Bool
  public var security: Beacon.SSLTrustValidator?
  public var enabledSSLCipherSuites: [Security.SSLCipherSuite]?
  public var isConnected: Swift.Bool {
    get
  }
  public var request: Foundation.URLRequest
  public var currentURL: Foundation.URL {
    get
  }
  public var respondToPingWithPong: Swift.Bool
  public init(request: Foundation.URLRequest, protocols: [Swift.String]? = nil, stream: Beacon.WSStream = FoundationStream())
  convenience public init(url: Foundation.URL, protocols: [Swift.String]? = nil)
  convenience public init(url: Foundation.URL, writeQueueQOS: Foundation.QualityOfService, protocols: [Swift.String]? = nil)
  open func connect()
  open func disconnect(forceTimeout: Foundation.TimeInterval? = nil, closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  open func write(string: Swift.String, completion: (() -> ())? = nil)
  open func write(data: Foundation.Data, completion: (() -> ())? = nil)
  open func write(ping: Foundation.Data, completion: (() -> ())? = nil)
  open func write(pong: Foundation.Data, completion: (() -> ())? = nil)
  public func newBytesInStream()
  public func streamDidError(error: Swift.Error?)
  @objc deinit
  @objc override dynamic public init()
}
extension Beacon.PusherChannelType : Swift.Equatable {}
extension Beacon.PusherChannelType : Swift.Hashable {}
extension Beacon.ConnectionState : Swift.Equatable {}
extension Beacon.ConnectionState : Swift.Hashable {}
extension Beacon.ConnectionState : Swift.RawRepresentable {}
@available(*, unavailable, renamed: "Connection")
extension Beacon.Reachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension Beacon.Reachability.NetworkStatus : Swift.Hashable {}
extension Beacon.Reachability.Connection : Swift.Equatable {}
extension Beacon.Reachability.Connection : Swift.Hashable {}
extension Beacon.CloseCode : Swift.Equatable {}
extension Beacon.CloseCode : Swift.Hashable {}
extension Beacon.CloseCode : Swift.RawRepresentable {}
extension Beacon.ErrorType : Swift.Equatable {}
extension Beacon.ErrorType : Swift.Hashable {}
extension Beacon.WebSocket.OpCode : Swift.Equatable {}
extension Beacon.WebSocket.OpCode : Swift.Hashable {}
extension Beacon.WebSocket.OpCode : Swift.RawRepresentable {}
